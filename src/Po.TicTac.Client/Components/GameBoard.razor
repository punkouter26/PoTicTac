@namespace PoTicTac.Client.Components
@using PoTicTac.Client.Models
@using Po.TicTac.Shared.Models

<div class="game-board-container">
    <div class="game-board retro-glow">
        @for (int row = 0; row < GameState.Board.GetLength(0); row++)
        {
            @for (int col = 0; col < GameState.Board.GetLength(1); col++)
            {
                var currentRow = row;
                var currentCol = col;
                var value = GameState.Board[row, col];
                var isLastMove = LastMove?.Row == row && LastMove?.Col == col;
                var isWinningCell = GameState.WinningCells?.Any(cell => cell != null && cell.Length >= 2 && cell[0] == row && cell[1] == col) == true;
                
                <div class="cell @GetCellClasses(value, isLastMove, isWinningCell, currentRow, currentCol)"
                     @onclick="() => HandleCellClick(currentRow, currentCol)"
                     data-tooltip="@GetCellTooltip(currentRow, currentCol, value)">
                    @GetCellSymbol(value)
                </div>
            }
        }
    </div>
</div>

@code {
    [Parameter] public GameBoardState GameState { get; set; } = new();
    [Parameter] public EventCallback<(int Row, int Col)> OnCellClick { get; set; }
    [Parameter] public LastMoveInfo? LastMove { get; set; }

    // Keep previous board snapshot to detect newly placed pieces and trigger animation
    private PlayerType[,]? _previousBoardSnapshot;
    private readonly HashSet<string> _droppingCells = new();

    private async Task HandleCellClick(int row, int col)
    {
        if (GameState.Board[row, col] == PlayerType.None && OnCellClick.HasDelegate)
        {
            await OnCellClick.InvokeAsync((row, col));
        }
    }

    private string GetCellClasses(PlayerType value, bool isLastMove, bool isWinningCell, int row, int col)
    {
        var classes = new List<string>();

        if (value != PlayerType.None)
            classes.Add("occupied");

        if (value == PlayerType.X)
            classes.Add("x-move");
        else if (value == PlayerType.O)
            classes.Add("o-move");

        if (isLastMove)
            classes.Add("last-move");

        if (isWinningCell)
            classes.Add("winning");

        var key = $"{row}-{col}";
        if (_droppingCells.Contains(key))
            classes.Add("dropping");

        return string.Join(" ", classes);
    }

    private string GetCellSymbol(PlayerType value)
    {
        return value switch
        {
            PlayerType.X => "X",
            PlayerType.O => "O",
            _ => ""
        };
    }

    private string GetCellTooltip(int row, int col, PlayerType value)
    {
        if (value != PlayerType.None)
        {
            return $"{GetCellSymbol(value)} at ({row + 1}, {col + 1})";
        }
        return $"Click to place at ({row + 1}, {col + 1})";
    }

    protected override void OnParametersSet()
    {
        // Initialize previous snapshot if null
        if (_previousBoardSnapshot == null && GameState?.Board != null)
        {
            _previousBoardSnapshot = (PlayerType[,])GameState.Board.Clone();
            return;
        }

        if (GameState?.Board == null || _previousBoardSnapshot == null)
            return;

        var rows = GameState.Board.GetLength(0);
        var cols = GameState.Board.GetLength(1);

        for (int r = 0; r < rows; r++)
        for (int c = 0; c < cols; c++)
        {
            var prev = _previousBoardSnapshot[r, c];
            var now = GameState.Board[r, c];

            if (prev == PlayerType.None && now != PlayerType.None)
            {
                var k = $"{r}-{c}";
                _droppingCells.Add(k);
                // Schedule removal of the dropping class
                _ = RemoveDroppingClassAfterDelay(k, 420);
            }
        }

        // Update snapshot
        _previousBoardSnapshot = (PlayerType[,])GameState.Board.Clone();
    }

    private async Task RemoveDroppingClassAfterDelay(string key, int delayMs)
    {
        try
        {
            await Task.Delay(delayMs);
            _droppingCells.Remove(key);
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            // ignore cancellation
        }
    }
}
